#pragma once
/*
_________________________________
Author: Longhao Qian
Data:   2020 08 11

propulsion blocks

1. CFM 56 N1, Fuel Flow and EGT
2. propeller model simple 
3. Propeller Model  Fixed Pitch
4. propeller model  variable pitch
5. Piston Engine Model
6. Brush electric motor model simple
__________________
*/
#include "Subsystem.h"
#include "UtilityFunctions.h"
namespace propulsionsystem {

	enum CFM56modelOutput {
		CFM56_OUTPUT_N1 = 0,
		CFM56_OUTPUT_EGT,
		CFM56_OUTPUT_FF
	};

	struct CFM56Parameter {

		struct  {
			double Tf;
			double b0;
			double b1;
			double b2;
			double k0;
			double power0;
			double k1;
			double c1;
			double k2;
			double c2;
		}CFM56N1model;

		struct {
			double b0;
			double k0;
			double b1;
			double k1;
			double c1;
			double environment_temp;
			double Tf;
		}CFM56EGTmodel;

		struct {
			double b0;
			double b1;
			double k0;
			double k1;
			double c0;
			double c1;
			double Tf;
			double d1;
			double power1;
		}CFM56FuelFlowmodel;
	};

	class CFM56AuxiliaryModel :
		public Subsystem
	{
	private:
		CFM56Parameter parameter;
		double N2_d;
		double N2_c;
		double invN1Tf;
		double invEGTTf;
		double invFFTf;
		double N1_input;
		double EGT_input;
		double FF_input;
		mathauxiliary::Lookup_2D Max;
		mathauxiliary::Lookup_2D Idel;
		double NormalizedIdleThrust;
		double NormalizedMaxThrust;
	public:
		CFM56AuxiliaryModel(const CFM56Parameter& param);
		void DifferentialEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input,
			VectorXd& derivative);
		void OutputEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input, VectorXd& output);
		void IncrementState();
		void DisplayParameters();
		void DisplayInitialCondition();
		~CFM56AuxiliaryModel();
	};

	enum CFM56ThrustInput {
		CFM56_INPUT_N1 = 0,
		CFM56_INPUT_Mach,
		CFM56_INPUT_Height
	};

	struct CF56ThrustModelParameter {
		VectorXd Mach;
		VectorXd Height;
		MatrixXd Max;
		MatrixXd Idle;
		double MaxThrust;
		double IdelN1;
		double MaxN1;
	};

	class CFM56ThrustModel :
		public Subsystem
	{
	private:
		CF56ThrustModelParameter parameter;
		double N1_dff;
		double Idle;
		double Max;
		mathauxiliary::Lookup_2D MaxLookUp;
		mathauxiliary::Lookup_2D IdelLookUp;
	public:
		CFM56ThrustModel(const CF56ThrustModelParameter& param);
		void DifferentialEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input,
			VectorXd& derivative);
		void OutputEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input, VectorXd& output);
		void IncrementState();
		void DisplayParameters();
		void DisplayInitialCondition();
		~CFM56ThrustModel();
	};
	/*----------------------- propeller simple fixed pitch ------------------------ */

	struct SimplePropellerParameter {
		double minimumAngularRate; // minimum angluar velocity to produce lift
		double MomentCoefficient; // the drag moment generated by propeller
		double ThrustCoefficient; // the thrust vs auglar velocity 
		bool   SpinningDirection; // spinning direction viewed from the front of the propeller, + : counter clock wise, -: clock wise
	};

	/*----------------------- propeller chart fixed pitch------------------------ */
	enum PropellerChartInput {
		PROPELLER_INPUT_N = 0, // RPS
		PROPELLER_INPUT_V,
		PROPELLER_INPUT_RHO,
		PROPELLER_INPUT_PITCH
	};
	enum PropellerChartOutput {
		PROPELLER_OUTPUT_T = 0,
		PROPELLER_OUTPUT_Q, // output required torque
	};

	struct PropellerChartFixedPitchParameter {
		Matrix<double, Eigen::Dynamic, 3> Chart; // J, CT, CP
		double minimumAngularRate;
		double diameter;
	};

	class PropellerChartFixedPitch :
		public Subsystem 
	{
	private:
		PropellerChartFixedPitchParameter parameter;
		double J;
		double D_4;// power of 4 of disc diameter
		double D_5;// power of 5 of disc diameter
		double N_2; // square of rotor speed
		VectorXd Coefficient; // CT  = 0, CP = 1
		mathauxiliary::Lookup_1D propeller_fixed_pitch_;
	public:
		PropellerChartFixedPitch(const PropellerChartFixedPitchParameter& param);
		void DifferentialEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input,
			VectorXd& derivative);
		void OutputEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input, VectorXd& output);
		void IncrementState();
		void DisplayParameters();
		void DisplayInitialCondition();
		~PropellerChartFixedPitch();
	};
	/*----------------------- propeller chart variable pitch------------------------ */
	struct PropellerChartVariablePitchParameter {
		MatrixXd Chart_T;
		MatrixXd Chart_P;
		VectorXd Jindex;
		VectorXd PitchIndex;
		double minimumAngularRate;
		double diameter;
	};

	class PropellerChartVariablePitch :
		public Subsystem
	{
	private:
		PropellerChartVariablePitchParameter parameter;
		double J;
		double CT;
		double CP;
		mathauxiliary::Lookup_2D propeller_table_T_;
		mathauxiliary::Lookup_2D propeller_table_P_;
		double D_4;// power of 4 of disc diameter
		double D_5;// power of 5 of disc diameter
		double N_2; // square of rotor speed
	public:
		PropellerChartVariablePitch(const PropellerChartVariablePitchParameter& param);
		void DifferentialEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input,
			VectorXd& derivative);
		void OutputEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input, VectorXd& output);
		void IncrementState();
		void DisplayParameters();
		void DisplayInitialCondition();
		~PropellerChartVariablePitch();
	};
	/*----------------------- piston engine ------------------------ */
	enum PistonEngineInput {
		PISTONENGINE_INPUT_THROTTLE = 0,
		PISTONENGINE_INPUT_MIXTURE,
		PISTONENGINE_INPUT_SHAFTRPS, // rps of shaft
		PISTONENGINE_INPUT_MANIFOLD,
		PISTONENGINE_INPUT_STARTER,
		PISTONENGINE_INPUT_FUELSTATE, // whether fuel is supplied
		PISTONENGINE_INPUT_SUPERCHARGER,
	};

	enum PistonEngineState {
		PISTONENGINE_STATE_OFF= 0,
		PISTONENGINE_STATE_ON,
	};

	enum PistonEngineOutput {
		PISTONENGINE_OUTPUT_STATE = 0,
		PISTONENGINE_OUTPUT_Q, // output torque
		PISTONENGINE_OUTPUT_FUELRATE,
	};
	/*-------- piston engine model------- */
	struct PistonEngineParameter {
		Eigen::Matrix<double, Dynamic, 2> PowerRPM_chart;
		Eigen::Matrix<double, Dynamic, 2> PowerFactor_mixture_chart;
		double starting_RPM;
		double shaft_damping;
		double starter_torque;
	};

	class PistonEngine :
		public Subsystem
	{
	private:
		PistonEngineParameter parameter;
		double EngineON;
	public:
		PistonEngine(const PistonEngineParameter& param);
		void DifferentialEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input,
			VectorXd& derivative);
		void OutputEquation(const double& t,
			const VectorXd& state,
			const VectorXd& input, VectorXd& output);
		void IncrementState();
		void DisplayParameters();
		void DisplayInitialCondition();
		~PistonEngine();
	};
	// TO DO: add electric motor:

	class BrushSimpleElectricMotor :
		public Subsystem
	{
	private:

	public:

	};
}